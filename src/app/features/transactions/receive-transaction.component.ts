import { Component, computed, effect, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import {
  AbstractControl,
  FormBuilder,
  FormControl,
  FormGroup,
  ReactiveFormsModule,
  ValidationErrors,
  Validators
} from '@angular/forms';
import { toDataURL } from 'qrcode';

import { WalletService } from '../../core/services/wallet.service';
import { PaymentRequestService } from '../../core/services/payment-request.service';
import { PaymentRequest } from '../../core/types/payment-request.types';

type RequestForm = FormGroup<{
  amount: FormControl<string>;
  memo: FormControl<string>;
  expiryMinutes: FormControl<string>;
}>;

const DECIMAL_FACTOR = 1_000_000_000n;
const AMOUNT_PATTERN = /^\d+(?:\.\d{1,9})?$/;
const EXPIRY_PATTERN = /^\d+$/;

@Component({
  selector: 'app-receive-transaction',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterLink],
  templateUrl: './receive-transaction.component.html',
  styleUrl: './receive-transaction.component.scss'
})
export class ReceiveTransactionComponent {
  private walletService = inject(WalletService);
  private paymentRequests = inject(PaymentRequestService);
  private formBuilder = inject(FormBuilder);

  readonly walletInfo = this.walletService.info;
  readonly isLocked = this.walletService.isLocked;
  readonly exists = this.walletService.exists;
  readonly createdAddress = this.walletService.createdAddress;

  readonly navigator = navigator;
  readonly supportsNfc = this.paymentRequests.supportsNfc();

  readonly qrCodeDataUrl = signal<string>('');
  readonly isGeneratingQR = signal(false);
  readonly isWritingNfc = signal(false);
  readonly requestError = signal<string | null>(null);
  readonly currentRequest = signal<PaymentRequest | null>(null);

  readonly isWalletReady = computed(() =>
    this.exists() && !this.isLocked() && this.createdAddress()
  );

  readonly walletAddress = computed(() => this.createdAddress() || '');

  requestForm!: RequestForm;

  private readonly amountValidator = (control: AbstractControl<string | null>): ValidationErrors | null => {
    const value = control.value?.trim() ?? '';
    if (!value) {
      return null;
    }
    if (!AMOUNT_PATTERN.test(value)) {
      return { amountFormat: true };
    }
    return null;
  };

  private readonly expiryValidator = (control: AbstractControl<string | null>): ValidationErrors | null => {
    const value = control.value?.trim() ?? '';
    if (!value) {
      return null;
    }
    if (!EXPIRY_PATTERN.test(value)) {
      return { expiryFormat: true };
    }
    const minutes = Number.parseInt(value, 10);
    if (!Number.isFinite(minutes) || minutes < 1 || minutes > 10080) {
      return { expiryRange: true };
    }
    return null;
  };

  constructor() {
    this.requestForm = this.formBuilder.nonNullable.group({
      amount: this.formBuilder.control('', { validators: [this.amountValidator], nonNullable: true }),
      memo: this.formBuilder.control('', { validators: [Validators.maxLength(140)], nonNullable: true }),
      expiryMinutes: this.formBuilder.control('15', { validators: [this.expiryValidator], nonNullable: true }),

    });

    effect(() => {
      const ready = this.isWalletReady();
      const request = this.currentRequest();
      const address = this.walletAddress();

      if (!ready) {
        if (request) {
          this.currentRequest.set(null);
        }
        this.qrCodeDataUrl.set('');
        return;
      }

      if (!request || request.address !== address) {
        if (this.requestForm.valid) {
          void this.createPaymentRequest(true);
        }
      }
    });
  }

  async ngOnInit() {
    if (this.isWalletReady()) {
      await this.createPaymentRequest(true);
    }
  }

  async createPaymentRequest(autoGenerated = false) {
    if (!this.isWalletReady()) {
      return;
    }

    if (!autoGenerated) {
      this.requestForm.markAllAsTouched();
    }

    if (!this.requestForm.valid) {
      this.requestError.set('Payment request details are invalid.');
      return;
    }

    const address = this.walletAddress();
    const amountInput = this.requestForm.controls.amount.value.trim();
    const memoInput = this.requestForm.controls.memo.value.trim();
    const expiryInput = this.requestForm.controls.expiryMinutes.value.trim();

    let amountBaseUnits: string | null = null;
    try {
      if (amountInput) {
        amountBaseUnits = this.toBaseUnits(amountInput);
      }
    } catch (error) {
      console.error('Invalid amount provided for payment request:', error);
      this.requestError.set('Amount must be a positive value with up to 9 decimal places.');
      return;
    }

    let expiresAt: string | null = null;
    if (expiryInput) {
      const minutes = Number.parseInt(expiryInput, 10);
      if (Number.isFinite(minutes) && minutes > 0) {
        const expiryMs = minutes * 60 * 1000;
        const expiryDate = new Date(Date.now() + expiryMs);
        expiresAt = expiryDate.toISOString();
      }
    }

    this.requestError.set(null);
    this.isGeneratingQR.set(true);

    try {
      const request = await this.paymentRequests.generate(address, {
        amountBaseUnits,
        memo: memoInput || null,
        expiresAt
      });

      this.currentRequest.set(request);
      await this.renderQrCode(request.uri);
    } catch (error) {
      console.error('Failed to create payment request:', error);
      this.requestError.set('Unable to create payment request. Please try again.');
      this.qrCodeDataUrl.set('');
    } finally {
      this.isGeneratingQR.set(false);
    }
  }

  private async renderQrCode(payload: string) {
    try {
      const dataUrl = await toDataURL(payload, {
        errorCorrectionLevel: 'M',
        margin: 1,
        scale: 8
      });
      this.qrCodeDataUrl.set(dataUrl);
    } catch (error) {
      console.error('Failed to render QR code using generator:', error);
      this.createFallbackQRCode(payload);
    }
  }

  private createFallbackQRCode(payload: string) {
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 200;
    const ctx = canvas.getContext('2d');

    if (ctx) {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 200, 200);
      ctx.fillStyle = '#000000';
      ctx.fillRect(20, 20, 160, 160);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(40, 40, 120, 120);
      ctx.fillStyle = '#000000';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('QR Fallback', 100, 110);
      ctx.fillStyle = '#666666';
      ctx.fillText(payload.slice(0, 16), 100, 130);
      ctx.fillStyle = '#666666';
      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('QR Code', 100, 175);
      ctx.fillText('Unavailable', 100, 190);

      this.qrCodeDataUrl.set(canvas.toDataURL());
    }
  }

  copyAddress() {
    const address = this.walletAddress();
    if (!address) return;

    navigator.clipboard.writeText(address).catch(error => {
      console.error('Failed to copy address:', error);
    });
  }

  generatePaymentLink() {
    return "";
  }

  shareAddress() {
    const address = this.walletAddress();
    if (!address) return;

    if (navigator.share) {
      navigator.share({
        title: 'My Chert Address',
        text: `Send CHERT to: ${address}`,
        url: this.generatePaymentLink()
      }).catch(error => {
        console.error('Failed to share:', error);
        // Fallback to copy
        this.copyAddress();
      });
    } else {
      // Fallback to copy
      this.copyAddress();
    }
  }

  sharePaymentRequest() {
    const request = this.currentRequest();
    if (!request) {
      return;
    }

    if (navigator.share) {
      navigator.share({
        title: 'Chert Payment Request',
        text: this.buildShareMessage(request),
        url: request.uri
      }).catch(error => {
        console.error('Failed to share payment request:', error);
        this.copyRequestLink();
      });
    } else {
      this.copyRequestLink();
    }
  }

  copyRequestLink() {
    const request = this.currentRequest();
    if (!request) {
      return;
    }

    navigator.clipboard.writeText(request.uri).catch(error => {
      console.error('Failed to copy payment link:', error);
    });
  }

  copyRequestToken() {
    const request = this.currentRequest();
    if (!request) {
      return;
    }

    navigator.clipboard.writeText(request.token).catch(error => {
      console.error('Failed to copy request token:', error);
    });
  }

  async writeRequestToNfc() {
    const request = this.currentRequest();
    if (!request || !this.supportsNfc || this.isWritingNfc()) {
      return;
    }

    this.isWritingNfc.set(true);
    try {
      await this.paymentRequests.writeToNfc(request);
    } catch (error) {
      console.error('Failed to write payment request to NFC tag:', error);
      this.requestError.set('Unable to write to NFC tag. Ensure the device supports Web NFC and try again.');
    } finally {
      this.isWritingNfc.set(false);
    }
  }

  prefillAmount(amount: string) {
    this.requestForm.controls.amount.setValue(amount);
  }

  truncateAddress(address: string): string {
    if (address.length <= 20) return address;
    return address.substring(0, 10) + '...' + address.substring(address.length - 8);
  }

  formatRequestAmount(request: PaymentRequest): string | null {
    if (!request.amountBaseUnits) {
      return null;
    }

    const value = BigInt(request.amountBaseUnits);
    const whole = value / DECIMAL_FACTOR;
    const fraction = value % DECIMAL_FACTOR;
    if (fraction === 0n) {
      return whole.toString();
    }

    let fractionStr = fraction.toString().padStart(9, '0');
    fractionStr = fractionStr.replace(/0+$/, '');
    return `${whole.toString()}.${fractionStr}`;
  }

  private toBaseUnits(amount: string): string {
    const trimmed = amount.trim();
    if (!trimmed) {
      throw new Error('Amount is required');
    }

    if (!AMOUNT_PATTERN.test(trimmed)) {
      throw new Error('Invalid amount format');
    }

    const [wholePart, fractionPart = ''] = trimmed.split('.');
    const whole = BigInt(wholePart);
    const paddedFraction = `${fractionPart}000000000`.slice(0, 9);
    const fraction = BigInt(paddedFraction);
    const value = whole * DECIMAL_FACTOR + fraction;

    if (value <= 0) {
      throw new Error('Amount must be positive');
    }

    return value.toString();
  }

  private buildShareMessage(request: PaymentRequest): string {
    const parts = [`Send CHERT to ${request.address}`];
    const formattedAmount = this.formatRequestAmount(request);
    if (formattedAmount) {
      parts.push(`Amount: ${formattedAmount} CHERT`);
    }
    if (request.memo) {
      parts.push(`Memo: ${request.memo}`);
    }
    parts.push(`Token: ${request.token}`);
    return parts.join('\n');
  }
}